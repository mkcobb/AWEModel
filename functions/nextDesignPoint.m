function p = nextDesignPoint(p)
if numel(p.Beta) == 0 % Use this part during initialization
    
    % Do the surface fit
    p.V{1} = inv((p.XInit'*p.XInit));
    p.Beta{1} = p.V{1}*p.XInit'*p.performanceIndexInit';
    
    % Calculate the gradient
    p.gradientTheta(end+1) = p.Beta{end}(2)+2*p.Beta{end}(3)*p.thetaIC;
    p.gradientPhi(end+1)   = p.Beta{end}(4)+2*p.Beta{end}(5)*p.phiIC;
    
    
    % Add the gradient to the current point, and saturate.
    p.widthsVec(1)  = p.thetaIC + sign(p.gradientTheta(end))*...
        abs(mink([p.thetaDistanceLim ,p.gradientTheta(end)],...
        1,'ComparisonMetho','abs'));
    p.heightsVec(1) = p.phiIC   + sign(p.gradientPhi(end))*...
        abs(mink([p.phiDistanceLim   ,p.gradientPhi(end)  ],...
        1,'ComparisonMethod','abs'));
    
    
    %     % Plotting (for debug purposes)
    %     figure
    %     % Plot Initialization Points
    %     h.initPts  = scatter3(p.thetaInit',p.phiInit',p.performanceIndexInit',...
    %         200*ones(size(p.thetaInit')),repmat([0 0 1],numel(p.thetaInit'),1),...
    %         'MarkerFaceColor','flat');
    %     hold on
    %     % Plot points which have been tested
    %     h.optPts = scatter3(p.widthsVec(1:end-1)',p.heightsVec(1:end-1)',p.performanceIndexOpt',...
    %         200*ones(size(p.widthsVec(1:end-1)')),repmat([1 0 0],numel(p.widthsVec(1:end-1)'),1),...
    %         'MarkerFaceColor','flat');
    %
    %     [phi,theta]=meshgrid(linspace(min([p.phiInit,p.heightsVec])-2*p.phiInitSep,max([p.phiInit,p.heightsVec])+2*p.phiInitSep),...
    %         linspace(min([p.thetaInit,p.widthsVec])-2*p.thetaInitSep,max([p.thetaInit,p.widthsVec])+2*p.thetaInitSep));
    %
    %     J = p.Beta{end}(1)*ones(size(phi))...
    %         +p.Beta{end}(2)*theta + p.Beta{end}(3)*theta.^2+...
    %         +p.Beta{end}(4)*phi   + p.Beta{end}(5)*phi.^2;
    %     % Plot our best guess of the surface
    %     h.surf = surf(theta,phi,J,'EdgeColor','none');
    %     % Plot the next point to be tested
    %     h.nextPt = scatter3(p.widthsVec(end),p.heightsVec(end),p.Beta{end}(1)+...
    %         p.Beta{end}(2)*p.widthsVec(end)  + p.Beta{end}(3)*p.widthsVec(end)^2+...
    %         p.Beta{end}(4)*p.heightsVec(end) + p.Beta{end}(5)*p.heightsVec(end)^2,200,[0 1 0],...
    %         'MarkerFaceColor','flat');
    %     xlabel('Width, $\theta$')
    %     ylabel('Height, $\phi$')
    %     zlabel('Performance Index')
    %     legend([h.initPts h.optPts h.surf h.nextPt],{'Init Points','Opt Points','Est. Surface','Next Pt'})
    %     drawnow
else % Use this part during optimization
    p.xOpt{end+1} = [1 p.widthsVec(end) p.widthsVec(end)^2 ...
        p.heightsVec(end) p.heightsVec(end)^2];
    V = p.V{end};
    x = p.xOpt{end};
    p.V{end+1}    = (1/p.forgettingFactor)*(V-(V*x'*x*V)/(1+x*V*x'));
    p.Beta{end+1} = p.Beta{end}+(p.V{end}*p.xOpt{end}')*...
        (p.performanceIndexOpt(end)-p.xOpt{end}*p.Beta{end});

    % Calculate the gradient at the current point
    p.gradientPhi(end+1)   = p.Beta{end}(4)+2*p.Beta{end}(5)*p.heightsVec(end);
    p.gradientTheta(end+1) = p.Beta{end}(2)+2*p.Beta{end}(3)*p.widthsVec(end);
    
    % Add the gradient to the current point, and saturate.
    p.widthsVec(end+1)  = p.widthsVec(end)  + sign(p.gradientTheta(end))*...
        abs(mink([p.thetaDistanceLim ,p.gradientTheta(end)],...
        1,'ComparisonMetho','abs'));
    p.heightsVec(end+1) = p.heightsVec(end) + sign(p.gradientPhi(end))*...
        abs(mink([p.phiDistanceLim   ,p.gradientPhi(end)  ],...
        1,'ComparisonMethod','abs'));
    
    % Plotting, for debug purposes
    figure
    
    % Plot Initialization Points
    h.initPts  = scatter3(p.thetaInit',p.phiInit',p.performanceIndexInit',...
        200*ones(size(p.thetaInit')),repmat([0 0 1],numel(p.thetaInit'),1),...
        'MarkerFaceColor','flat');
    hold on
    % Plot points which have been tested
    h.optPts = scatter3(p.widthsVec(1:end-1)',p.heightsVec(1:end-1)',p.performanceIndexOpt',...
        200*ones(size(p.widthsVec(1:end-1)')),repmat([1 0 0],numel(p.widthsVec(1:end-1)'),1),...
        'MarkerFaceColor','flat');
    
    [phi,theta]=meshgrid(linspace(min([p.phiInit,p.heightsVec])-2*p.phiInitSep,max([p.phiInit,p.heightsVec])+2*p.phiInitSep),...
        linspace(min([p.thetaInit,p.widthsVec])-2*p.thetaInitSep,max([p.thetaInit,p.widthsVec])+2*p.thetaInitSep));
    
    J = p.Beta{end}(1)*ones(size(phi))...
        +p.Beta{end}(2)*theta + p.Beta{end}(3)*theta.^2+...
        +p.Beta{end}(4)*phi   + p.Beta{end}(5)*phi.^2;
    % Plot our best guess of the surface
    h.surf = surf(theta,phi,J,'EdgeColor','none');
    % Plot the next point to be tested
    h.nextPt = scatter3(p.widthsVec(end),p.heightsVec(end),p.Beta{end}(1)+...
        p.Beta{end}(2)*p.widthsVec(end)  + p.Beta{end}(3)*p.widthsVec(end)^2+...
        p.Beta{end}(4)*p.heightsVec(end) + p.Beta{end}(5)*p.heightsVec(end)^2,200,[0 1 0],...
        'MarkerFaceColor','flat');
    % Plot the gradient vector
    h.gradVector = plot3(...
        [p.widthsVec(end-1) p.widthsVec(end)]  ,...
        [p.heightsVec(end-1) p.heightsVec(end)],...
        [p.performanceIndexOpt(end) p.Beta{end}(1)+...
        p.Beta{end}(2)*p.widthsVec(end)  + p.Beta{end}(3)*p.widthsVec(end)^2+...
        p.Beta{end}(4)*p.heightsVec(end) + p.Beta{end}(5)*p.heightsVec(end)^2]);
    xlabel('Width, $\theta$')
    ylabel('Height, $\phi$')
    zlabel('Performance Index')
    legend([h.initPts h.optPts h.surf h.nextPt h.gradVector],{'Init Points','Opt Points','Est. Surface','Next Pt','Grad. Dir.'})
    campos(1000*[0.209902353989809  -0.002779101393152   2.157563994825425])
    drawnow
end

end